package org.flexiblepower.defpi.lightsimulator;

import java.io.Serializable;
import java.time.Instant;
import java.util.Calendar;
import java.util.Collection;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

import javax.annotation.Generated;

import org.flexiblepower.defpi.lightsimulator.inflexible_controller.InstructionStatusSender;
import org.flexiblepower.defpi.lightsimulator.inflexible_controller.MeasurementPublisher;
import org.flexiblepower.defpi.lightsimulator.inflexible_controller.efi_20.xml.CurtailmentProfile;
import org.flexiblepower.defpi.lightsimulator.inflexible_controller.efi_20.xml.CurtailmentProfileElement;
import org.flexiblepower.defpi.lightsimulator.inflexible_controller.efi_20.xml.InstructionStatus;
import org.flexiblepower.defpi.lightsimulator.inflexible_controller.efi_20.xml.Measurement;
import org.flexiblepower.defpi.lightsimulator.inflexible_controller.efi_20.xml.Measurement.ElectricityMeasurement;
import org.flexiblepower.defpi.lightsimulator.observation_publisher.ObservationPublisher;
import org.flexiblepower.defpi.lightsimulator.observation_publisher._1.proto.ObservationPublisher_1Proto.Observation;
import org.flexiblepower.defpi.lightsimulator.observation_publisher._1.proto.ObservationPublisher_1Proto.Observation.NumberDatapoint;
import org.flexiblepower.defpi.lightsimulator.observation_publisher._1.proto.ObservationPublisher_1Proto.Observation.NumberDatapoint.Unit;
import org.flexiblepower.service.DefPiParameters;
import org.flexiblepower.service.Service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * LightSimulator provides an implementation of the Light Simulator service
 *
 * File generated by org.flexiblepower.create-service-maven-plugin.
 * NOTE: This file is generated as a stub, and has to be implemented by the user. Re-running the codegen plugin will
 * not change the contents of this file.
 * Template by TNO, 2017
 *
 * @author coenvl
 */
@Generated(value = "org.flexiblepower.plugin.servicegen", date = "Nov 8, 2017 4:10:45 PM")
public class LightSimulator implements Service<LightSimulatorConfiguration> {

    private final Logger log = LoggerFactory.getLogger(LightSimulator.class);

    private final HashMap<String, ScheduledFuture<?>> futureCurtailMents = new HashMap<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);

    private LightSimulatorConfiguration configuration;
    private DefPiParameters params;

    private Thread activeCurtailmentThread;

    private final Collection<ObservationPublisher> observers = new LinkedList<>();
    private final Collection<MeasurementPublisher> efiHandlers = new LinkedList<>();

    private double currentPower;

    @Override
    @SuppressWarnings("unchecked")
    public void resumeFrom(final Serializable state) {
        this.futureCurtailMents.putAll((Map<? extends String, ? extends ScheduledFuture<?>>) state);
    }

    @Override
    public void init(final LightSimulatorConfiguration config, final DefPiParameters parameters) {
        this.modify(config);
        this.params = parameters;
        this.setPowerUsage(config.getMaximumPower());
        this.scheduler.scheduleAtFixedRate(() -> this.publishObservation(),
                config.getPublishInterval() / 2,
                config.getPublishInterval(),
                TimeUnit.SECONDS);
    }

    @Override
    public void modify(final LightSimulatorConfiguration config) {
        this.configuration = config;
    }

    @Override
    public Serializable suspend() {
        return this.futureCurtailMents;
    }

    @Override
    public void terminate() {
        this.activeCurtailmentThread.interrupt();
        this.setPowerUsage(this.configuration.getMinimumPower());
    }

    public LightSimulatorConfiguration getConfig() {
        return this.configuration;
    }

    public void addObservationPublisher(final ObservationPublisher op) {
        this.observers.add(op);
        op.observe(this.createPowerObservation());
    }

    public void removeObservationPublisher(final ObservationPublisher op) {
        this.observers.remove(op);
    }

    public void addMeasurementPublisher(final MeasurementPublisher mp) {
        this.efiHandlers.add(mp);
        mp.publishMeasurement(this.createMeasurement());
    }

    public void removeMeasurementPublisher(final MeasurementPublisher mp) {
        this.efiHandlers.remove(mp);
    }

    /**
     * @param instructionId
     */
    public boolean removeCurtailment(final String instructionId) {
        if (this.futureCurtailMents.containsKey(instructionId)) {
            final ScheduledFuture<?> f = this.futureCurtailMents.get(instructionId);
            f.cancel(true);
            // See if we are interrupting an active curtailment
            if (f.getDelay(TimeUnit.MILLISECONDS) <= 0) {
                this.setPowerUsage(this.configuration.getMaximumPower());
            }
            return true;
        }
        return false;
    }

    /**
     * @param instructionId
     * @param profile
     */
    public void addCurtailMent(final String instructionId,
            final CurtailmentProfile profile,
            final InstructionStatusSender updateSender) {
        final Calendar start = profile.getStartTime().toGregorianCalendar();
        final long delay = Math.max(0, start.getTimeInMillis() - new GregorianCalendar().getTimeInMillis());

        this.log.info("Scheduling curtailment after {} ms", delay);
        this.futureCurtailMents.put(instructionId,
                this.scheduler
                        .schedule(() -> this.runCurtailment(profile, updateSender), delay, TimeUnit.MILLISECONDS));
    }

    /**
     * @param instructionId
     * @return
     */
    private void runCurtailment(final CurtailmentProfile curtailMent, final InstructionStatusSender updateSender) {
        if ((this.activeCurtailmentThread != null) && this.activeCurtailmentThread.isAlive()) {
            // Stop the (previous) running curtailment
            this.activeCurtailmentThread.interrupt();
        }
        this.activeCurtailmentThread = Thread.currentThread();

        // Trigger the start sign
        if (updateSender != null) {
            updateSender.sendUpdate(InstructionStatus.STARTED);
        }

        for (final CurtailmentProfileElement element : curtailMent.getCurtailmentProfileElement()) {
            final long curtailmentTimeMillis = element.getDuration().getTimeInMillis(new GregorianCalendar());

            this.setPowerUsage(element.getValue());

            try {
                Thread.sleep(curtailmentTimeMillis);
            } catch (final InterruptedException e) {
                this.log.info("Curtailment interrupted");
                return;
            }
        }

        // Finished curtailing... go back to maximum power
        if (updateSender != null) {
            updateSender.sendUpdate(InstructionStatus.SUCCEEDED);
        }
        this.setPowerUsage(this.configuration.getMaximumPower());
    }

    /**
     * @param maximumPower
     */
    private void setPowerUsage(final double power) {
        this.log.info("Updating power usage to {} W", power);
        this.currentPower = power;
        this.publishObservation();
    }

    private void publishObservation() {
        this.log.debug("Sending observation to {} observers", this.observers.size());
        this.observers.forEach(op -> op.observe(this.createPowerObservation()));

        this.log.debug("Sending measurement to {} efi sessions", this.efiHandlers.size());
        this.efiHandlers.forEach(eh -> eh.publishMeasurement(this.createMeasurement()));
    }

    private Measurement createMeasurement() {
        return new Measurement().withElectricityMeasurement(new ElectricityMeasurement().withPower(this.currentPower));
    }

    /**
     * @return
     */
    private Observation createPowerObservation() {
        final String now = Instant.now().toString();
        final NumberDatapoint datapoint = NumberDatapoint.newBuilder()
                .setName("Power")
                .setUnit(Unit.W)
                .setValue(this.currentPower)
                .build();
        return Observation.newBuilder()
                .setObserverId(this.getClass().getSimpleName())
                .setProcessId(this.params.getProcessId())
                .addNumberDatapoints(datapoint)
                .setMeasuredAt(now)
                .setObservedAt(now)
                .build();
    }

}
